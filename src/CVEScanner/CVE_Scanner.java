package CVEScanner;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

import CVEScanner.checkers.Busybox;
import CVEScanner.checkers.Checker;
import CVEScanner.checkers.Curl;
import CVEScanner.checkers.Dnsmasq;
import CVEScanner.checkers.Hostapd;
import CVEScanner.checkers.Openssl;
import CVEScanner.DB.DBConnection;
import org.apache.maven.artifact.versioning.DefaultArtifactVersion;


public class CVE_Scanner {

	
	public static void main(String[] args) throws SQLException {
		
	
        
        //Step 1 Gather binaries
        //Step 2 Parse binaries
        //Step 3 Scan versions
        //Step 4 Cross reference CVE data from database
		
		
		Checker checker = new Busybox();
		
		
		String[] arr = {"dnsmasq-2.20", "part of OpenSSL 1.0.2f ","BusyBox v1.22.1", "curl 7.30.0"};
		
		
		
		
		var checker_version = checker.get_version(arr, "dnsmasq"); //Move this to VersionScanner. Get name from file
		
		//Add logic for when file ISNT the scanned binary. So when result is UNKNOWN, say the file can't be for sure
		//if .get("version") not "UNKNOWN", then say it is the relevant binary
		
		
		
		if (!checker_version.get("version").equals("UNKNOWN")) {
			System.out.println("This file " +checker_version.get("is_or_contains") + " " + checker.VENDOR_PRODUCT.get(1));
			System.out.println("Version : "+checker_version.get("version"));
			
			
			DBConnection  dbConnection = new DBConnection("cve.db");
			
			Connection conn = dbConnection.connection;
			Statement statement = dbConnection.connection.createStatement();
			statement.setQueryTimeout(15);
			
			
			
			List<String> cve_list = new LinkedList<String>();
			
			
			String query_any_marked = String.format("SELECT CVE_number FROM cve_range "
					+ "WHERE vendor = '%s' AND product = '%s' AND version = '%s'"
					
					,checker.VENDOR_PRODUCT.get(0),
					checker.VENDOR_PRODUCT.get(1),
					checker_version.get("version"));
			
			
			
			ResultSet rs1 = statement.executeQuery(query_any_marked);
			
			
			while (rs1.next()) {
				
				cve_list.add(rs1.getString("cve_number"));
			}
			
			
			
			
			
			
			String query_any_range = String.format("SELECT cve_number, versionStartIncluding, versionStartExcluding, versionEndIncluding, versionEndExcluding FROM cve_range "
					+ "WHERE vendor = '%s' AND product = '%s' AND version = '%s'"
					
					,checker.VENDOR_PRODUCT.get(0),
					checker.VENDOR_PRODUCT.get(1),
					"*");
			
			
			ResultSet rs2 = statement.executeQuery(query_any_range);
			
			
			
			//List<String> rs2_list = new ArrayList<String>();
		
			
			
			
			
			
			
			
			while (rs2.next()) {
				
				//System.out.println("cve_number = "+ rs.getString("cve_number"));
				
				DefaultArtifactVersion parsed_version = new DefaultArtifactVersion(checker_version.get("version"));
				
				String cve_number = rs2.getString(1);
				String versionStartIncluding = rs2.getString(2);
				String versionStartExcluding = rs2.getString(3);
				
				String versionEndIncluding = rs2.getString(4);
				String versionEndExcluding = rs2.getString(5);
				
				
				
				
				DefaultArtifactVersion VSI = new DefaultArtifactVersion(versionStartIncluding);
				DefaultArtifactVersion VSE = new DefaultArtifactVersion(versionStartExcluding);
				
				DefaultArtifactVersion VEI = new DefaultArtifactVersion(versionEndIncluding);
				DefaultArtifactVersion VEE = new DefaultArtifactVersion(versionEndExcluding);
				
				
				
				
				///check start range
				boolean passes_start = false;
				
				
				if(!versionStartIncluding.equals("") && parsed_version.compareTo(VSI) >= 0 ) {
					
					//System.out.println(parsed_version.compareTo(VSI) + " "+versionStartIncluding);
					passes_start = true;
				}
				
				
				if(!versionStartExcluding.equals("") && parsed_version.compareTo(VSE) > 0 ) {
					
					//System.out.println(parsed_version.compareTo(VSI) + " "+versionStartIncluding);
					passes_start = true;
				}
				
				
				if(versionStartIncluding.equals("") && versionStartExcluding.equals("")) {
					
					passes_start = true;
				}     
				
				
				
				
				///check end range
				boolean passes_end = false;
				
				if(!versionEndIncluding.equals("") && parsed_version.compareTo(VEI) <= 0) {
					
					
						//System.out.println(parsed_version.compareTo(VEI) + " "+versionEndIncluding);
						passes_end = true;
						
					
				}
				
				
				if(!versionEndExcluding.equals("") && parsed_version.compareTo(VEE) < 0) {
					
					
						//System.out.println(parsed_version.compareTo(VEI) + " "+versionEndIncluding);
						passes_end = true;
					
				
				}
				
				
				if(versionEndIncluding.equals("") && versionEndExcluding.equals("")) {
					
					passes_end = true;
				}
				
				
				
				
				if(passes_start && passes_end) {
					cve_list.add(cve_number);
				}
				
			}
			
			
			for (var item : cve_list) {
				System.out.println(item);
			}
			System.out.println("\n"+cve_list.size());
			
			
			
			if(conn != null) {
				conn.close();
			}
			
			
			
			
		}
		else {
			System.out.println("File is not of type '" + checker.VENDOR_PRODUCT.get(1)+"'");
		}
		
		
		
		
		
		
		
    }
}
	
	
